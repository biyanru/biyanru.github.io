###### Hibernate概述
- 是一款方便应用操作数据库的中间件，使应用直接通过操作Java对象来操作数据库。
- 实现了ORM模型，包括：数据库表与JAVA对象的映射，表关联与Java对象关系的映射。
- 实现了ORM操作，包括：对表数据的增删改查，对表的级联操作等。
- 提供了方言机制，增加了应用在不同底层数据库之间的可移植性。
- 提供了JNDI，统一进行数据库访问配置。
- 提供了缓存机制，减少了对物理数据源的访问频率，提高数据库操作性能。

###### Hibernate概念
- 实体：Java对象，映射到表。
- 表：数据库表，映射到实体。
- SessionFactory：会话工厂，统一管理会话。一个数据库对应一个SessionFactory。
- Session：会话，应用与数据库之间的一次交互。
- 事务：全部成功或全部失败。
- 一级缓存：事务级缓存，缓存事务隔离，Hibernate内嵌缓存。
- 二级缓存：进程级缓存，SessionFactory共享缓存，Hibernate可配置缓存。

###### Hibernate初始化
- 配置Sessionfactory与数据库的映射。
- 配置方言。
- 配置二级缓存的底层缓存。

###### Hibernate实体三态
- 瞬时态：一种新的持久性实例，被 Hibernate 认为是瞬时的，它不与 Session 相关联，在数据库中没有与之关联的记录且无标识符值。
- 持久态：可以将一个瞬时状态实例通过与一个 Session 关联的方式将其转化为持久状态实例。持久状态实例在数据库中没有与之关联的记录，有标识符值，并与一个 Session 关联。
- 脱管态：一旦关闭 Hibernate Session，持久状态实例将会成为脱管状态实例。

###### Hibernate二级缓存
Hibernate先从一级缓存查找数据，再从二级缓存查找数据。二级缓存是SessionFactory共享的，因此比较适合一下两种数据：
- 不会有多个事务并发访问的数据。
- 会有多个事务并发访问，但几乎不修改的数据。

Hibernate提供了四种并发策略，提供事务隔离措施：
- Transactional（事务）：它提供了Repeatable Read事务隔离级别。它可以防止脏读和不可重复读这类的并发问题。
- Read-write（读写）：读写策略提供了“read committed"数据库隔离级别。对于经常被读但很少修改的数据可以采用这种策略，它可以防止读脏数据。
- Nonstrict-read-write（非严格读写）：非严格读写不能保证缓存与数据库中数据的一致性，如果存在两个事务并发地访问缓存数据的可能，则应该为该数据配置一个很短的过期时间，以减少读脏数据的可能。对于极少被修改，并且可以容忍偶尔脏读的数据可以采用这种并发策略。
- Read-only（只读）：对于永远不会被修改的数据可以采用这种并发访问策略，它的并发性能是最高的。但必须保证数据不会被修改，否则就会出错。

###### 事务隔离级别
数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。

1. Read uncommitted

    读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。
    事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。
    分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。

**那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。**
2. Read committed

    读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。
    事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…
    分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。

**那怎么解决可能的不可重复读问题？Repeatable read ！**
3. Repeatable read

    重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
    事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。
    分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。

> 什么时候会出现幻读？

> 事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

**那怎么解决幻读问题？Serializable！**
4. Serializable 序列化

    Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。
